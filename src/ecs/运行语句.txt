运行本地测试
python ecs.py TrainData_2015.1.1_2015.2.19.txt input_5flavors_cpu_7days.txt output.txt
python ecs.py TrainData_2015.1.1_2015.2.19.txt input_15flavors_cpu_7days.txt output.txt
python ecs.py TrainData_2015.1.1_2015.2.19.txt input_15flavors_cpu_7days.txt output.txt
运行打包程序
tar -czvf my.tar.gz  src/


或者
tar -czvf my.tar.gz src/ecs/ecs.py src/ecs/learn/*.py src/ecs/ecs.py src/ecs/linalg/*.py src/ecs/ecs.py src/ecs/predictions/*.py src/ecs/backpack.py src/ecs/ensemble.py src/ecs/load_data.py src/ecs/metrics.py src/ecs/model_selection.py src/ecs/preprocessing.py src/ecs/utils.py

最新打包：
tar -czvf -6day_5.tar.gz src/ecs/*.py src/ecs/*.txt src/ecs/learn/*.py src/ecs/ecs.py src/ecs/linalg/*.py src/ecs/ecs.py src/ecs/predictions/*.py 


src/ecs/paramater/*.*


new:
tar -czvf day15_26.tar.gz  src/ecs/ecs.py src/ecs/predictor.py src/ecs/utils.py src/ecs/backpack.py src/ecs/paramater.py  src/ecs/linalg/*.py src/ecs/learn/*.py src/ecs/load_data.py src/ecs/preprocessing.py


运行批量评测
python evaluate.py train
python evaluate.py test


C:/python27/python.exe evaluate_TestData_2015.2.20_2015.2.27_TrainData_2015.1.1_2015.2.19.py


from linalg.common import dim,square,minus,mean,sum
from linalg.vector import argsort

from linalg.matrix import diag,matrix_matmul,matrix_transpose
from linalg.common import shape


class KNN_Regressor:
    def __init__(self,k=3,dynamic=False):
        self.X = None
        self.y = None
        self.k = k
        self.dynamic = dynamic
        
        self.shape_X = None
        self.shape_Y = None


    def fit(self,X,y):
        self.X = X
        if dim(y) == 1:
            self.y = [[k] for k in y]
        else:
            self.y = y
        self.shape_X = shape(X)
        self.shape_Y = shape(y)

    def predict(self,X):
        result = []
        # dim_X = dim(X)

        if dim(X) == 1:
            X = [X]
        for x in X:
            loss = sum(square(minus(self.X,x)),axis=1)

            index = argsort(loss)[:self.k]

            ys = []
            for i in index:
                ys.append(self.y[i])

            if self.dynamic:
                k_loss_raw = sorted(loss)[:self.k]
                k_loss = [1/l if l!=0 else 0 for l in k_loss_raw]
                k_loss_sum = sum(k_loss)
                weights = [l/float(k_loss_sum) if k_loss_sum!=0 else 1 for l in k_loss]
                weight_m = diag(weights)
                ys = matrix_matmul(weight_m,ys)
                result.append(sum(ys,axis=0))
            else:
                result.append(mean(ys,axis=0))


        if len(self.shape_Y)==1:
            result = matrix_transpose(result)[0]

        return result  